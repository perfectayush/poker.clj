(use 'poker.core)
(hand-rank ace-srth)
dir
(dir poker.core)
(hand-analyze ace-strh)
(hand-analyze ace-srth)
(hand-rank (hand-analyze ace-srth))
(conj (hand-rank (hand-analyze ace-srth)) (hand-sort ace-strh))
(conj (hand-rank (hand-analyze ace-srth)) (hand-sort ace-srth))
(cons (hand-rank (hand-analyze ace-srth)) (hand-sort ace-srth))
(cons (hand-sort ace-srth) (hand-rank (hand-analyze ace-srth)))
(conj (hand-sort ace-srth) (hand-rank (hand-analyze ace-srth)))
(cons (hand-sort ace-srth) (hand-rank (hand-analyze ace-srth)))
(cons (hand-sort ace-srth) (vec (hand-rank (hand-analyze ace-srth))))
(conj (hand-sort ace-srth) (vec (hand-rank (hand-analyze ace-srth))))
(conj (vec (hand-sort ace-srth))  (hand-rank (hand-analyze ace-srth)))
(hand-rank (hand-analyze ace-srth))
(hand-sort ace-srth)
(conj 4 [14 5 23])
(conj  [14 5 23] 4)
(conj [4] [14 5 23])
(vec (hand-sort ace-srth))
(conj (vec (hand-rank (hand-analyze ace-srth))) (hand-sort ace-srth))
(vec 4)
(vec '(4))
(vec (list 4))
(conj (->> ace-srth hand-analyze hand-rank list vec))) (hand-sort ace-srth))
(conj (->> ace-srth hand-analyze hand-rank list vec) (hand-sort ace-srth))
(require 'poker.core)
(require poker.core)
(require 'poker.core)
(require poker.core)
(require 'poker.core)
(poker-hands-sort '(threek fourk strh ace-strh))
(poker.core/poker-hands-sort '(threek fourk strh ace-strh))
(poker.core/poker-hands-sort (vec '(threek fourk strh ace-strh)))
(poker.core/poker-hands-sort (list (threek fourk strh ace-strh))
)
(use 'poker.core)
(poker-hands-sort (list (threek fourk strh ace-strh))
)
(poker-hands-sort (list (threek fourk strh ace-srth)))
(list (threek fourk strh ace-srth)
)
(vec (threek fourk strh ace-srth))
(threek fourk strh ace-srth)
'(threek fourk strh ace-srth)
'(`threek `fourk `strh `ace-srth)
`(threek fourk strh ace-srth)
`((eval threek) (eval fourk) (eval strh) (eval ace-srth))
(conj () threek)
(conj () threek fourk)
(poker-hands-sort (conj () threek fourk strh ace-srth))
(map poker-hand (poker-hands-sort (conj () threek fourk strh ace-srth)))
(use 'poker.core :reload)
(map poker-hand (poker-hands-sort (conj () threek fourk strh ace-srth)))
(use 'poker.core :reload)
(poker-hands-sort (conj () threek fourk strh ace-strh six-strh))
(map poker-value (poker-hands-sort (conj () threek fourk strh ace-strh six-strh)))
(map poker-hand (poker-hands-sort (conj () threek fourk strh ace-strh six-strh)))
(poker-hand "AH 4C 6H 3H 9H")
(poker-hand "AH AC 6H 3H 9H")
(poker-hand "AH AC AH 3H 9H")
(poker-hand "AH AC 9H 3H 9H")
(poker-hand "AH AC AH AH 9H")
(poker-hand "AH AC AH AH AH")
(poker-hand "AH AC AH AH CH")
(poker-hand "AH AC AH AH 2H")
(poker-hand "AH AC AH 2H 2H")
(poker-hand "AH AH AH 2H 2H")
(poker-hand "AH 2H 3H 2H 2H")
(poker-hand "AH 2H 3H 4H 5H")
(poker-hand "AH KH QH JH TH")
(poker-hand "AH AC AH 2H 2H")
(poker-hand "AH AC 2H 2H 2H")
(poker-hands-sort (conj () threek fourk strh ace-strh six-strh)))
(poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
(use 'poker.core :reload)
(poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
(use 'poker.core :reload)
(poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
(->> hand                                                                                                              
  52 │  2 │          (partition-by identity)                                                                                            
  53 │  3 │          (map count))
(use 'poker.core :reload)
(poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
print-stack-trace
(print-stack-trace)
(pst (poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
)
(pst (poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D")))
(poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
(use 'poker.core :reload)
(poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
(use 'poker.core :reload)
(poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
(print-stack-trace *e 5)
(pst *e 5)
(poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
(pst *e 100)
(use 'poker.core :reload)
(poker-hands-sort '("9S 9H TC TH TS" "AS AH 2C 2S 2D"))
(poker-hands-sort '("9S 9H 9C TH TS" "AS AH 2C 2S 2D" ""))
(poker-hands-sort '("9S 9H 9C TH TS" "AS AH 2C 2S 2D"))
(poker-hands-sort '("9S 9H 9C TH TS" "AS AH 2C 2S 2D" "TC TS AS AC AD"))
(use 'poker.core :reload)
(poker-hands-sort '("9S 9H 9C TH TS" "AS AH 2C 2S 2D" "TC TS AS AC AD"))
(pst *e 100)
(use 'poker.core :reload)
(poker-hands-sort '("9S 9H 9C TH TS" "AS AH 2C 2S 2D" "TC TS AS AC AD"))
(use 'poker.core :reload)
(poker-hands-sort '("9S 9H 9C TH TS" "AS AH 2C 2S 2D" "TC TS AS AC AD"))
(require 'clojure.math.combinatorics)
(def ranks "dasfsa")
(def suits "SHCD")
(clojure.math.combinatorics/cartesian-product ranks suits)
(doseq (clojure.math.combinatorics/cartesian-product ranks suits))
(str dsf)
(str \d \s \f)
(map str (clojure.math.combinatorics/cartesian-product ranks suits))
(apply str (clojure.math.combinatorics/cartesian-product ranks suits))
(doall(clojure.math.combinatorics/cartesian-product ranks suits))
(map str (doall (clojure.math.combinatorics/cartesian-product ranks suits)))
(doseq [k (clojure.math.combinatorics/cartesian-product ranks suits)] (str k))
(str (\s \k))
(str '(\s \k))
(str `(\s \k))
(str ~(\s \k))
(apply str (\s \k))
(apply str \s \k)
(apply str (\s \k))
(apply str [\s \k])
(map str (\s \k))
(map str [\s \k[)
(map str [\s \k])
(apply map str [\s \k])
(apply str (clojure.math.combinatorics/cartesian-product ranks suits))
(prn (apply str (clojure.math.combinatorics/cartesian-product ranks suits)))
(clojure.math.combinatorics/cartesian-product ranks suits)
(doseq [k (clojure.math.combinatorics/cartesian-product ranks suits)] (prn (apply str k)))
(doseq [k (clojure.math.combinatorics/cartesian-product ranks suits)] (apply str k))
(map (apply str) (clojure.math.combinatorics/cartesian-product ranks suits))
(map #(apply str %1 %2) (clojure.math.combinatorics/cartesian-product ranks suits))
(map apply str (clojure.math.combinatorics/cartesian-product ranks suits))
(apply map str (clojure.math.combinatorics/cartesian-product ranks suits))
(map apply str (clojure.math.combinatorics/cartesian-product ranks suits))
(apply apply str (clojure.math.combinatorics/cartesian-product ranks suits))
(apply (apply str) (clojure.math.combinatorics/cartesian-product ranks suits))
(apply (apply) (clojure.math.combinatorics/cartesian-product ranks suits))
(apply #(apply str %) (clojure.math.combinatorics/cartesian-product ranks suits))
(apply str (clojure.math.combinatorics/cartesian-product ranks suits))
(str \a \b)
(str (\a \b))
(str '(\a \b))
(apply str (\a \b))
(apply str '(\a \b))
(apply str ('(\a \b) '(\c \d)))
(apply str '('(\a \b) '(\c \d)))
(apply  (apply str) '('(\a \b) '(\c \d)))
(apply  (apply str) ('(\a \b) '(\c \d)))
(apply apply str ('(\a \b) '(\c \d)))
(apply apply str '('(\a \b) '(\c \d)))
(apply apply str '((\a \b) (\c \d)))
(apply map str '((\a \b) (\c \d)))
(apply map str ranks suits)
(list "sfd")
(apply map str (split ranks) (split suits))
(split ranks)
(seq "dsaf")
(apply map str (seq ranks) (seq suits))
(apply map str ((seq ranks) (seq suits)))
(apply map str (seq ((seq ranks) (seq suits))))
(seq "sdfSAf" "sadfSd"
)
(seq ("sdfSAf" "dsfasdf")
)
(seq '("sdfSAf" "dsfasdf")
)
(seq `("sdfSAf" "dsfasdf")
)
(apply map str (seq `((seq ranks) (seq suits))))
ranks
suits
(for [x ranks y suits](str x y))
(shuffle '(1 2 3 4))
(requrie '[poker.deck :as d]0
)
(requrie '[poker.deck :as d])
(require '[poker.deck :as d])
(shuffle [1 2 3 4]0
)
(shuffle [1 2 3 4])
(require '[poker.deck :as d])
(split "sfsfdsfjsfsdf" "s")
(split "sfsfdsfjsfsdf" #"\s")
(split "sfsfds fjs fsdf" #"\s")
(clojure.string/split "sfsfds fjs fsdf" #"\s")
(require '[poker.deck :as deck])
ls
(deck/texas-deal 2)
(first (deck/texas-deal 2))
(def s (first (deck/texas-deal 2)))
s
(juxt s)
(interleave s)
(interleave (first s) (last s))
(partition 2 (interleave (first s) (last s)))
(first (deck/texas-deal 3))
(partition 2 (interleave (first s) (last s)))
(def s (first (deck/texas-deal 5)))
s
(partition 2 (interleave (first s) (last s)))
(require '[poker.deck :as deck])
(deck/texas-deal 2)
(deck/texas-deal 5)
(deck/texas-deal 10)
(deck/texas-deal 13)
(require '[clojure.math.combinatorics :as combo])
(combo/combinations 1 2 3 4)
(combo/combinations [1 2 3] 2)
(combo/combinations [1 2 3 4 5] 2)
(cons 1 2) 
(cons 1 (2)) 
(cons 1 [2]) 
(cons 1 [2 4]) 
(cons [1] [2 4]) 
(cons [1] 2 4) 
(conj [1] 2 4) 
(conj [1] 2 4 6) 
(conj [1] 2 4 6 7) 
(conj '(1) 2 4 6 7) 
(cons 4 '(1) )
(cons 6 4 '(1))
(cons 6 '( 6 8 1))
(cons 7 '( 6 8 1))
(cons '( 6 8 1) 7)
(cons '( 6 8 1) [0])
(conj '( 6 8 1) [0])
(conj '( 6 8 1) 1 2 3)
(require '[poker.deck :as deck])
(use '[clojure.math.combinatorics :only [combinations])
(use '[clojure.math.combinatorics :only [combinations]])
(combinations [1 2 3 4] 2)
(combinations '("ds" "sd" "dss") 2)
.
ls
(require '[poker.deck :as deck])
(deck/combinations
)
(use '[clojure.math.combinatorics :only combinatioins])
(use '[clojure.math.combinatorics :only [combinatioins]])
(use '[clojure.math.combinatorics :only [combinations]])
(def s (deck/texas-deal 4))
s
(:phands s)
(first (:phands s))
(first (:flop s))
(:flop s)
(combinations (first (:flop s)) (:flop s))
(combinations [(first (:flop s)) (:flop s)] 2)
(combinations (conj (first (:phands s)) (:flop s) (:turn s) (:river s))
)
(combinations (conj (first (:phands s)) (:flop s) (:turn s) (:river s)) 5)
(conj (first (:phands s)) (:flop s) (:turn s) (:river s))
(conj ((:flop s) (:turn s) (:river s))
)
(conj (:flop s) (:turn s) (:river s))
(concat (:phands s) (conj (:flop s) (:turn s) (:river s)))
(concat (first (:phands s)) (conj (:flop s) (:turn s) (:river s)))
(combinations (concat (first (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5)
(require '[poker.logic :as logic])
(map logic/poker-hand  (combinations (concat (first (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5)
)
(map logic/poker-hand-sort  (combinations (concat (first (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5))
(logic/poker-hand-sort  (combinations (concat (first (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5))
(logic/poker-hands-sort  (combinations (concat (first (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5))
(map logic/poker-hand (logic/poker-hands-sort  (combinations (concat (first (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5)))
(first (logic/poker-hands-sort  (combinations (concat (first (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5)))
(first (logic/poker-hands-sort  (combinations (concat (last (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5)))
(poker-hand (first (logic/poker-hands-sort  (combinations (concat (last (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5))))
(logic/poker-hand (first (logic/poker-hands-sort  (combinations (concat (last (:phands s)) (conj (:flop s) (:turn s) (:river s))) 5))))
(deck/texas-deal 4)
(deck/texas-deal 10)
(deck/texas-deal 30)
(deck/texas-deal 13)
(deck/texas-deal 15)
(deck/texas-deal 18)
(deck/texas-deal 25)
(deck/texas-deal 24)
(deck/texas-deal 23)
(deck/texas-deal 22)
(deck/texas-deal 23)
(deck/texas-deal 9)
(deck/texas-deal 4)
(key sfs)
(key "sfs")
(keys "sfs")
(keyword "sfs")
(str (range 5))
(range 5)
(str "sdf" (range 5))
(str "sdf" `(range 5))
(str "sdf" `(~range 5))
(str "sdf" ~(range 5))
~(range 5)
(range 5)
`(~range 5)
(range 5)
(keyword (range 5))
(doseq [num (range 5)] (str "this" (str num)))
(for [x (range 5) y "player"] (str x y))
(for [x (range 5)] (str "player" x ))
(for [x (range 5)] (str "player-" x ))
(map keyword (for [x (range 5)] (str "player-" x )))
(for [x (range 5)] (str "player-" x ))
(map keyword (for [x (range 5)] (str "player-" x )))
(assoc {} (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5])
(assoc {} (interleave (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5]))
 (interleave (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5]))
(interleave (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5])))
(interleave (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5])
(into {} (interleave (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5]))
(into {} (interleave (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5])))
(into {} (interleave (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5]))
(hash-map (interleave (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5]))
(apply hash-map (interleave (map keyword (for [x (range 5)] (str "player-" x ))) [1 2 3 4 5]))
(require '[poker.deck :as deck])
(deck/texas-deal 4)
(deck/texas-deal 3)
(deck/texas-deal 13)
(require '[poker.deck :as deck])
(deck/texas-deal 13)
(require '[poker.deck :as deck])
(deck/texas-deal 13)
(:phands (deck/texas-deal 13))
(keyword sdf)
(require '[poker.deck :as deck])
(deck/winner (4))
(require '[poker.deck :as deck] :reload)
(deck/winner (deck/texas-deal 4))
(require '[poker.deck :as deck] :reload)
(deck/winner (deck/texas-deal 4))
(require '[poker.deck :as deck] :reload)
(deck/winner (deck/texas-deal 4))
(require '[poker.deck :as deck] :reload)
(deck/winner (deck/texas-deal 4))
clear
clean
(require '[poker.deck :as deck] :reload)
(deck/winner (deck/texas-deal 4))
(require '[poker.deck :as deck] :reload)
(deck/winner (deck/texas-deal 4))
(require '[poker.deck :as deck] :reload)
(deck/winner (deck/texas-deal 4))
(deck/winner (deck/texas-deal 5))
(require '[poker.deck :as deck] :reload)
(deck/winner (deck/texas-deal 5))
(require '[poker.deck :as deck] :reload)
(deck/winner (deck/texas-deal 5) :flop)
(deck/winner (deck/texas-deal 5) :turn)
(def s (deck/texas-deal 5))
s
(deck/winner s :flop)
(deck/winner s :turn)
(deck/winner s :river)
(def s (deck/texas-deal 5))
(deck/winner s :turn)
(deck/winner s :river)
(def s (deck/texas-deal 5))
(deck/winner s :river)
(def s (deck/texas-deal 5))
(deck/winner s :river)
(deck/winner s :turn)
(deck/winner s :flop)
s
(deck/winner s :river)
